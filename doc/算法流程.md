# 程序流程

1. 以邻接矩阵的形式读入带权无向图$G=(V,E)$；
2. 如果图的节点数非常少($\le5$个)，则暴力枚举所有可能的路径排列，选取其中的最优回路，并返回；
3. 使用克里斯托菲德斯算法(Christofides algorithm)求解图$G$中的一条哈密顿回路$H$；
4. 使用3-opt算法优化回路$H$。

# 1. 克里斯托菲德斯算法

**简介**：

克里斯托菲德斯算法是旅行商问题在度量空间（即距离对称且满足三角不等式）上的一个近似算法。该算法可以保证相对最优哈密尔顿回路长度有3/2的近似比。尼科斯·克里斯托菲德斯 (Nicos Christofides) 于1976年首次发表了这个算法，故以他的名字命名之。截至2017年，这一算法仍然是一般性旅行商问题的算法中近似比最好的结果。

**输入**：一个边权非负的无向图$G=(V,E)$

**输出**：一条经过所有节点并回到起点的回路$H$，回路的上边权之和尽可能短。

**流程**：

1. 计算读入图的最小生成树，构成子图$T$；
2. 找到子图$T$中度数为奇数的节点，构成节点集合$O$；
3. 只由节点集合$O$和图$G$中的边集合E构成的子图$O'$；
4. 计算子图$O'$的最小权完美匹配，构成子图$M$；
5. 合并子图$T$和子图$M$，得到欧拉多重图$U$(即包含欧拉回路的多重图)；
6. 计算欧拉多重图$U$的的一条欧拉回路$U'$；
7. 将欧拉回路$U'$转换成哈密顿回路$H$，输出$H$。

**细节**：

1. 在代码实现时使用邻接矩阵进行输入，$|E|=|V|*(|V|-1)/2$；
2. 使用普里姆算法(Prim algorithm)求解最小生成树；
3. 由欧拉定理，连通图中度数为奇数的节点的个数为偶数，因此子图$O'$必然存在完美匹配；
4. 一般图的最小权完美匹配问题一般使用时间复杂度为$O(|V||E|\log|V|)$或$O(|V|^3)$的带花树算法(Blossom Algorithm)。但因为其实现较难，且我们的程序使用了3-opt算法对本算法所求路径进行了进一步优化，因此我们决定使用较为简单的贪心算法求解图的近似最小权匹配完美匹配；
5. 使用希尔霍尔策算法(Hierholzer's algorithm)计算欧拉多重图的欧拉回路；
6. 使用遍历的方法将欧拉回路转换成哈密顿回路。

**时间复杂度**：

$O(|V|^2)$

## 1.1 普里姆算法

**简介**：

普里姆算法是一种求解加权连通图最小生成树的算法，基本思想是从一个节点开始，不断将与生成树中已有节点距离最小的新节点加入到生成树中，直到中所有节点都被加入。

**输入**：以三元组$e=(u,v,w)$的形式读入图中的边e的集合$E$，其中$u$和$v$是边的两个端点，$w$是边的权重。

**输出**：构成最小生成树的子图$T$

**流程**：

1. 任选一个节点$u$，加入子图$T$；
2. 当还有节点没有加入子图$T$时，找到距离子图$T$上的点距离最短的点$v$，将$v$和最短的边$e$加入子图$T$，并重复这一步。

**细节**：

1. 使用数组$dist[|V|]$记录每个未被加入子图$T$的节点距离子图$T$上的点的最短距离，并使用数组$pre[|V|]$记录最短距离所对应的边的另一个端点；
2. 子图$T$每新加入一个节点$u$，对于与$u$相邻且未加入子图$T$的所有节点$v$，如果$u$与$v$的距离比$dist[v]$小，则更新$dist[v]$为$u$到$v$的距离，并将$pre[v]$更新为$u$；
3. 每次从$dist$数组中找到最小值，并将最小值所对应的节点下标$u$和代表最短边另一个端点的$pre[u]$加入到子图$T$中。

**时间复杂度**：

普里姆算法在以邻接矩阵存储形的稠密图上的时间复杂度为$O(|V|^2)$。

与另一种常见的最小生成树算法——克鲁斯卡尔算法(Kruskal Algorithm)相比，克鲁斯卡尔算法的时间复杂度为$O(|E|\log|E|)=O(|V|^2\log|V|^2)$，在稠密图上的表现不如普里姆算法。

我们的程序使用的是邻接矩阵形式存储的稠密图，因此选用普里姆算法的效果更优秀。

## 1.2 贪心算法求解图的近似最小权匹配完美匹配

**输入**：一个边权非负的无向图$O'$

**输出**：一个近似的最小权匹配的完美匹配子图$M$

**流程**：

1. 每次任选一个未加入子图$M$的节点$u$，找到未加入子图$M$的所有节点中与$u$距离最近的节点$v$，将$u$、$v$和以$uv$为端点的边加入子图$M$；

**时间复杂度**：

$O(|V|^2)$

## 1.3 希尔霍尔策算法

**简介**：

希尔霍尔策算法是一种用来寻找欧拉回路的图算法。由数学家卡尔·希尔霍尔策给出。使用了类似贪心的思路。

**输入**：一个欧拉多重图$H$

**输出**：一条欧拉回路$U$

**流程**：

1. 维护一个栈(Stack)；
2. 选择任意一个节点$s$作为当前点，将$s$入栈；
3. 当栈不空时，从栈顶取出一个节点$u$作为当前节点，否则结束算法；
4. 如果$u$存在一个相邻的节点$v$，则将节点$v$入栈，并令当前节点$u:=v$；否则将$u$加入欧拉回路$U$；
5. 返回第3步。

**细节**：

1. 子图$M$中每个点的度数一定为偶数，因此可以选择任意节点作为欧拉回路的起点；
2. 为了在无向无权图中支持常数时间复杂度的查询节点相邻边和删除边的操作，我们选用了十字双向链表的方式存储图；
3. 最小生成树$T$中边集合的数量为$|V|-1$，最小权完美匹配$M$中边集合的数量为$|V|/2$，因此$H$中边集合的数量不会超过$\lfloor|V|*3/2\rfloor$；所有节点度数都是偶数的欧拉回路中点的数量不会超过边的数量，因此栈中的元素最多也不会超过边的数量，因此可以申请固定大小数组并按静态栈进行实现。

**时间复杂度**：

$O(|V|)$

### 1.3.1 十字双向链表

**简介**：

在我们的程序的实现中，用十字双向链表存储无向无权图时，存在两种类型的节点，分别为边节点和顶点节点。

边节点有6个域：端点1$p1$、端点2$p2$、指向从端点1开始遍历的前一条边和后一条边的2个指针$prev1$、$next1$，指向从端点2开始遍历的前一条边和后一条边的2个指针$prev2$、$next2$。

顶点节点有1个域：从此顶点开始遍历的第一条边的指针`first_edge`。

**操作实现**：

1 **建图**：

1. 分配顶点节点数组`Vex[V]`，以支持常数时间复杂度的按序号查询顶点。
2. 将所有顶点节点的`first_edge`设为空指针。
3. 遍历边的集合，为每条边分配一个边节点`new_edge`，以类似于双向链表插入节点的方式执行：

```cpp
new_edge.p1 = p1;
new_edge.next1 = Vex[p1].first_edge;
new_edge.prev1 = nullptr;
if (Vex[p1].first_edge != nullptr) Vex[p1].first_edge->prev1 = new_edge;
Vex[p1].first_edge = new_edge;
new_edge.p2 = p2;
new_edge.next2 = Vex[p2].first_edge;
new_edge.prev2 = nullptr;
if (Vex[p2].first_edge != nullptr) Vex[p2].first_edge->prev2 = new_edge;
Vex[p2].first_edge = new_edge;
```

2 **查询相邻边**：

1. 直接访问`Vex[v].first_edge`并判断是否等于空指针即可。

3 **删除边**：

1. 对于边节点`del_edge`，以类似于双向链表删除节点的方式执行：

```cpp
(Vex[del_edge.p1].first_edge == del_edge ? Vex[del_edge.p1].first_edge : del_edge.prev1->next1) = del_edge.next1;
if (del_edge.next1 != nullptr) del_edge.next1->prev1 = del_edge.prev1;
(Vex[del_edge.p2].first_edge == del_edge ? Vex[del_edge.p2].first_edge : del_edge.prev2->next2) = del_edge.next2;
if (del_edge.next2 != nullptr) del_edge.next2->prev2 = del_edge.prev2;
```

**说明**：

在实际代码实现时，由于已知边的数量$\lfloor|V|*3/2\rfloor$，因此可以一次性将边节点全部分配至数组。

### 1.3.2 静态栈

**简介**：

栈是一种后进先出的数据结构，需要实现的操作有：

1. 压栈：将元素$e$压入栈中；
2. 出栈：将栈顶元素$e$弹出；
3. 检查：检查栈是否为空。

**细节**：

1. 因为已知栈的最大所需容量，在实现时只需要申请一个数组`Stack[MAX]`，并使用一个指针变量`sp`指向栈顶

**操作实现**：

1. 建栈：分配栈数组`Stack[MAX]`，令`sp = &Stack[0]`；
2. 压栈：将元素$e$压入栈中的操作为`*sp++ = e`；
3. 出栈：将栈顶元素$e$弹出的操作为`e=*--sp`；
4. 检查：检查栈是否为空的操作为`return sp == &Stack[0]`。

**时间复杂度**：

均为$O(1)$。

## 1.4 遍历欧拉回路得到哈密顿回路

**输入**：一条欧拉回路$U$

**输出**：一条哈密顿回路$H$

**流程**：

1. 遍历欧拉回路，在每个节点第一次被访问时加入哈密顿回路$H$。

**细节**：

1. 建立一个标志位数组$visited$并将每个位置初始化为$0$，其中$visited[i]$表示节点$i$是否被访问过；
2. 每遍历到一个点$u$时，如果$visited[u]=0$，则将$u$加入哈密顿回路$H$，并令$visited[u]:=1$。

**时间复杂度**：

$O(|V|)$

# 2. 3-opt 算法

**简介**：

3-opt算法是一种针对TSP问题的局部搜索算法，每次通过枚举回中3条不相邻的边，并尝试用不同的方式连接这些边的6个顶点来得到一条更短的回路。是一种启发式算法。

**输入**：一个无向图$G$和图中的一条哈密顿回路$H$

**输出**：一个新的边权和更小的哈密顿回路$H$。

**流程**：

1. 使用3重循环枚举3重循环枚举回路中不相邻的3条边；
2. 对于每次枚举到的3条边，删掉这3条边，并在保证回路连通性的情况下枚举3条边上6个顶点的连接方式组合，并使用距离最短的方式重新连接这6个点。
3. 重新开始以上步骤，直到不能再使回路总长度变短。

**细节**：

1. 我们称本算法使用1次3重循环为1次迭代。仅迭代1次所需的时间复杂度高达$O(|V|^3)$，不可能让算法一直运行下去。因此我们分别提供了设定最大迭代次数和最小优化阈值的参数。当迭代次数超过最大迭代次数，或某1次迭代所优化的距离迭代前的总距离的比值小于最小优化阈值时，终止迭代。
2. 常见的哈密顿回路表示方式是使用一个数组$H[|V|]$，代表回路中第$i$个位置为算法输入的图$G$中第$H[i]$个顶点，$H[i]$与$H[i+1]$相邻$(1\le i\le|V|)$，$H[|V|]$与$H[1]$相邻。在这种表示方法下，如果想要重连$H[i]-H[i+1]$和$H[j]-H[j+1]$两条边，需要将路径从$H[i+1]$到$H[j]$的部分进行翻转，即将$H[i+1\dots j+1]$的全部内容反向。这样的方式会让1轮迭代的时间复杂度变为$O(|V|^3*|V|)=O(|V|^4)$。为了实现常数时间复杂度的路径翻转，我们使用了一种特殊的双向链表对回路进行表示。

## 2.1 哈密顿回路的双向链表表示法

使用双向链表来表示回路是一种自然的想法，如果希望是一段路径反向，可以直接将这段路径的第1个前驱节点连接到这段路径的末尾，并将这段路径第1个的后继节点连接到这段路径的开头。

但是这样的操作并不能修改存在于这段路径中的节点的方向，因此我们无法分辨双向链表节点的两个链域分别应该指向这个节点的前驱节点还是后继节点。

我们的解决方案是：在遍历链表节点时，除了保存当前节点的指针$cur$，还额外保存一个当前节点的前驱节点的指针$pre$。在遍历下一个节点时，先使用$pre$与$cur$的两个链域做比较，选择其中不等于$pre$的链域作为$cur$的后继节点，将$cur$赋值给$pre$，并将后继节点赋值给$cur$。

选择记录当前节点的前驱节点$pre$而不是记录当前节点的后继节点的原因是：算法在编码实现时需要频繁交换连接两个节点的后继节点，只保留前驱节点可以减少额外的赋值操作。

**操作实现**：

1 **访问前驱/后继节点**

如上所述。

2 **翻转区间**

1. 输入需要反转的区间的第1个前驱节点`before_first`和这段区间的最后一个节点`before_last`；
2. 通过`before_first`和`before_last`得到这段区间的第1个节点`first`和第1个后继节点`last`；
3. 将`before_first`的后继节点设置为`before_last`；
4. 将`before_last`的前驱节点设置为`before_first`；
5. 将`first`的后继节点设置为`last`；
6. 将`last`的前驱节点设置为`first`；
7. 令`before_last:=first`，即保持`before_last`在3重循环时所指向的位置不发生改变。

**时间复杂度**：

均为$O(1)$
