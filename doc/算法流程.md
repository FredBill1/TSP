# 程序流程

1. 以邻接矩阵的形式读入带权无向图$G=(V,E)$；
2. 如果图的节点数非常少($\le5$个)，则暴力枚举所有可能的路径排列，选取其中的最优回路，并返回；
3. 使用克里斯托菲德斯算法(Christofides algorithm)求解图$G$中的一条哈密顿回路$H$；
4. 使用3-opt算法优化回路$H$。

# 1. 克里斯托菲德斯算法

**简介**：

克里斯托菲德斯算法是旅行商问题在度量空间（即距离对称且满足三角不等式）上的一个近似算法。该算法可以保证相对最优哈密尔顿回路长度有3/2的近似比。尼科斯·克里斯托菲德斯 (Nicos Christofides) 于1976年首次发表了这个算法，故以他的名字命名之。截至2017年，这一算法仍然是一般性旅行商问题的算法中近似比最好的结果。

**输入**：一个边权非负的无向图$G=(V,E)$

**输出**：一条经过所有节点并回到起点的回路$H$，回路的上边权之和尽可能短。

**流程**：

1. 计算读入图的最小生成树，构成子图$T$；
2. 找到子图$T$中度数为奇数的节点，构成节点集合$O$；
3. 只由节点集合$O$和图$G$中的边集合E构成的子图$O'$；
4. 计算子图$O'$的最小权完美匹配，构成子图$M$；
5. 合并子图$T$和子图$M$，得到欧拉多重图$U$(即包含欧拉回路的多重图)；
6. 计算欧拉多重图$U$的的一条欧拉回路$U'$；
7. 将欧拉回路$U'$转换成哈密顿回路$H$，输出$H$。

**细节**：

1. 在代码实现时使用邻接矩阵进行输入，$|E|=|V|*(|V|-1)/2$；
2. 使用克鲁斯卡尔算法(Kruskal algorithm)求解最小生成树；
3. 由欧拉定理，连通图中度数为奇数的节点的个数为偶数，因此子图$O'$必然存在完美匹配；
4. 一般图的最小权完美匹配问题一般使用时间复杂度为$O(|V||E|\log|V|)$或$O(|V|^3)$的带花树算法(Blossom Algorithm)。但因为其实现较难，且我们的程序使用了3-opt算法对本算法所求路径进行了进一步优化，因此我们决定使用较为简单的贪心算法求解图的近似最小权匹配完美匹配；
5. 使用希尔霍尔策算法(Hierholzer's algorithm)计算欧拉多重图的欧拉回路；
6. 使用遍历的方法将欧拉回路转换成哈密顿回路。

**时间复杂度**：

$O(|E|\log|E|)=O(|V|^2\log(|V|^2))$

## 1.1 克鲁斯卡尔算法

**简介**：

克鲁斯卡尔算法是一种常见并且好写的最小生成树算法，基本思想是从小到大加入边，是个贪心算法。

**输入**：以三元组$e=(u,v,w)$的形式读入图中的边e的集合$E$，其中$u$和$v$是边的两个端点，$w$是边的权重。

**输出**：构成最小生成树的子图$T$

**流程**：

1. 将$E$中所有边$e$按边权$w$升序排序；
2. 按升序遍历排序后的边集合$E$，如果遍历到的边$e$的两个端点$u$和$v$不在同一个连通分量中，则把边$e$加入到子图$T$中。

**细节**：

1. 对边权排序的过程使用快速排序算法 (Quick sort)；
2. 使用带路径压缩的并查集数据结构对连通分量进行维护 (Union–find data structure)。

**时间复杂度**：

取决于快速排序和并查集的复杂度，为$O(|E| \log|E|)$。

### 1.1.1 快速排序

**简介**：

快速排序，又称分区交换排序(partition-exchange sort)，简称快排，是一种被广泛运用的排序算法。

**输入**：一个长度为$N$的线性表，需要线性表支持使用迭代器进行双向遍历的操作。

**输出**：排好序的线性表。

**流程**：

1. 如果线性表的长度$N\le1$，则结束算法；
2. 选择一个基准元素$pivot$，将线性表分成两个子表，左子表中的元素都比$pivot$小，右子表中的元素都比$pivot$大；
3. 递归到两个子表中分别进行快速排序。

**细节**：

1. 在实现时，每次选择线性表的第一个元素作为基准元素$pivot$。

**时间复杂度**：

最优时间复杂度和平均时间复杂度为$O(N\log N)$，最坏时间复杂度为$O(N^2)$。在后续分析复杂度时，将快速排序的复杂度均视为$O(N\log N)$。

### 1.1.2 带路径压缩的并查集

**简介**：

并查集是一种树形的数据结构，用于处理一些不交集的**合并**及**查询**问题。 它支持两种操作：

1. **查找**：确定某个元素处于哪个子集；
2. **合并**：将两个子集合并成一个集合。

**操作实现**：

1 **初始化**

1. 输入节点总个数$N$，申请一个长度为$N$的数组$parent$，其中$parent[i]$表示节点$i$的父节点；
2. 将每个节点的父节点初始化为它本身，即$parent[i]:=i$。

2 **查找**

1. 查找祖先：查询元素$e$所属的集合时，先输入一个节点$e$，如果$e$的父节点不是$e$本身，则将$e$的父节点赋值给$e$，然后继续向上查找，直到$e$的父节点是$e$本身为止，即得到节点$e$的最远祖先节点$ancestor$；
2. 路径压缩：将这条查找路径上的所有节点的父节点都赋值为节点$e$的最远祖先节点$ancestor$；
3. 返回结果：$ancestor$即为元素$e$所著的集合，返回$ancestor$。

3 **合并**

1. 输入两个元素$u$、$v$，查找这两个元素的最远祖先$ancestor_u$、$ancestor_v$；
2. 如果$ancestor_u=ancestor_v$，说明这两个元素已经在同一个集合中，返回合并失败；
3. 否则令$ancestor_u$的父节点指向$ancestor_v$，即$parent[ancestor_u]:=ancestor_v$，并返回合并成功。

**时间复杂度**：

麻了 看不懂

<https://oi-wiki.org/ds/dsu-complexity/#unionxy>

## 1.2 贪心算法求解图的近似最小权匹配完美匹配

**输入**：一个边权非负的无向图$O'$

**输出**：一个近似的最小权匹配的完美匹配子图$M$

**流程**：

1. 将$E$中所有边$e$按边权$w$升序排序
2. 按升序遍历排序后的边集合$E$，如果遍历到的边$e$的两个端点$u$和$v$均不在子图$M$中，则把边$e$和它的两个端点$u$、$v$加入到子图$M$中

**时间复杂度**：

取决于排序的复杂度，为$O(|E|\log|E|)$

## 1.3 希尔霍尔策算法

**简介**：

希尔霍尔策算法是一种用来寻找欧拉回路的图算法。由数学家卡尔·希尔霍尔策给出。使用了类似贪心的思路。

**输入**：一个欧拉多重图$H$

**输出**：一条欧拉回路$U$

**流程**：

1. 维护一个栈(Stack)；
2. 选择任意一个节点$s$作为当前点，将$s$入栈；
3. 当栈不空时，从栈顶取出一个节点$u$作为当前节点，否则结束算法；
4. 如果$u$存在一个相邻的节点$v$，则将节点$v$入栈，并令当前节点$u:=v$；否则将$u$加入欧拉回路$U$；
5. 返回第3步。

**细节**：

1. 子图$M$中每个点的度数一定为偶数，因此可以选择任意节点作为欧拉回路的起点；
2. 为了在无向无权图中支持常数时间复杂度的查询节点相邻边和删除边的操作，我们选用了十字双向链表的方式存储图；
3. 最小生成树$T$中边集合的数量为$|V|-1$，最小权完美匹配$M$中边集合的数量为$|V|/2$，因此$H$中边集合的数量不会超过$\lfloor|V|*3/2\rfloor$；所有节点度数都是偶数的欧拉回路中点的数量不会超过边的数量，因此栈中的元素最多也不会超过边的数量，因此可以申请固定大小数组并按静态栈进行实现。

**时间复杂度**：

$O(|V|)$

### 1.3.1 十字双向链表

**简介**：

在我们的程序的实现中，用十字双向链表存储无向无权图时，存在两种类型的节点，分别为边节点和顶点节点。

边节点有6个域：端点1$p1$、端点2$p2$、指向从端点1开始遍历的前一条边和后一条边的2个指针$prev1$、$next1$，指向从端点2开始遍历的前一条边和后一条边的2个指针$prev2$、$next2$。

顶点节点有1个域：从此顶点开始遍历的第一条边的指针$first_edge$。

**操作实现**：

1 **建图**：

1. 分配顶点节点数组`Vex[V]`，以支持常数时间复杂度的按序号查询顶点。
2. 将所有顶点节点的`first_edge`设为空指针。
3. 遍历边的集合，为每条边分配一个边节点`new_edge`，以类似于双向链表插入节点的方式执行：

```cpp
new_edge.p1 = p1;
new_edge.next1 = Vex[p1].first_edge;
new_edge.prev1 = nullptr;
if (Vex[p1].first_edge != nullptr) Vex[p1].first_edge->prev1 = new_edge;
Vex[p1].first_edge = new_edge;
new_edge.p2 = p2;
new_edge.next2 = Vex[p2].first_edge;
new_edge.prev2 = nullptr;
if (Vex[p2].first_edge != nullptr) Vex[p2].first_edge->prev2 = new_edge;
Vex[p2].first_edge = new_edge;
```

2 **查询相邻边**：

1. 直接访问`Vex[v].first_edge`并判断是否等于空指针即可。

3 **删除边**：

1. 对于边节点`del_edge`，以类似于双向链表删除节点的方式执行：

```cpp
(Vex[del_edge.p1].first_edge == del_edge ? Vex[del_edge.p1].first_edge : del_edge.prev1->next1) = del_edge.next1;
if (del_edge.next1 != nullptr) del_edge.next1->prev1 = del_edge.prev1;
(Vex[del_edge.p2].first_edge == del_edge ? Vex[del_edge.p2].first_edge : del_edge.prev2->next2) = del_edge.next2;
if (del_edge.next2 != nullptr) del_edge.next2->prev2 = del_edge.prev2;
```

**说明**：

在实际代码实现时，由于已知边的数量$\lfloor|V|*3/2\rfloor$，因此可以一次性将边节点全部分配至数组。

### 1.3.2 静态栈

**简介**：

栈是一种后进先出的数据结构，需要实现的操作有：

1. 压栈：将元素$e$压入栈中；
2. 出栈：将栈顶元素$e$弹出；
3. 检查：检查栈是否为空。

**细节**：

1. 因为已知栈的最大所需容量，在实现时只需要申请一个数组`Stack[MAX]`，并使用一个指针变量`sp`指向栈顶

**操作实现**：

1. 建栈：分配栈数组`Stack[MAX]`，令`sp = &Stack[0]`；
2. 压栈：将元素$e$压入栈中的操作为`*sp++ = e`；
3. 出栈：将栈顶元素$e$弹出的操作为`e=*--sp`；
4. 检查：检查栈是否为空的操作为`return sp == &Stack[0]`。

**时间复杂度**：

均为$O(1)$。

## 1.4 遍历欧拉回路得到哈密顿回路

**输入**：一条欧拉回路$U$

**输出**：一条哈密顿回路$H$

**流程**：

1. 遍历欧拉回路，在每个节点第一次被访问时加入哈密顿回路$H$。

**细节**：

1. 建立一个标志位数组$visited$并将每个位置初始化为$0$，其中$visited[i]$表示节点$i$是否被访问过；
2. 每遍历到一个点$u$时，如果$visited[u]=0$，则将$u$加入哈密顿回路$H$，并令$visited[u]:=1$。

**时间复杂度**：

$O(|V|)$

# 2. 3-opt 算法

**简介**：

3-opt算法是一种针对TSP问题的局部搜索算法，每次通过枚举回中3条不相邻的边，并尝试用不同的方式连接这些边的6个顶点来得到一条更短的回路。是一种启发式算法。

**输入**：一个无向图$G$和图中的一条哈密顿回路$H$

**输出**：一个新的边权和更小的哈密顿回路$H$。

**流程**：

1. 使用3重循环枚举3重循环枚举回路中不相邻的3条边；
2. 对于每次枚举到的3条边，删掉这3条边，并在保证回路连通性的情况下枚举3条边上6个顶点的连接方式组合，并使用距离最短的方式重新连接这6个点。
3. 重新开始以上步骤，直到不能再使回路总长度变短。

**细节**：

1. 我们称本算法使用1次3重循环为1次迭代。仅迭代1次所需的时间复杂度高达$O(|V|^3)$，不可能让算法一直运行下去。因此我们分别提供了设定最大迭代次数和最小优化阈值的参数。当迭代次数超过最大迭代次数，或某1次迭代所优化的距离迭代前的总距离的比值小于最小优化阈值时，终止迭代。
2. 常见的哈密顿回路表示方式是使用一个数组$H[|V|]$，代表回路中第$i$个位置为算法输入的图$G$中第$H[i]$个顶点，$H[i]$与$H[i+1]$相邻$(1\le i\le|V|)$，$H[|V|]$与$H[1]$相邻。在这种表示方法下，如果想要重连$H[i]-H[i+1]$和$H[j]-H[j+1]$两条边，需要将路径从$H[i+1]$到$H[j]$的部分进行翻转，即将$H[i+1\dots j+1]$的全部内容反向。这样的方式会让1轮迭代的时间复杂度变为$O(|V|^3*|V|)=O(|V|^4)$。为了实现常数时间复杂度的路径翻转，我们使用了一种特殊的双向链表对回路进行表示。

## 2.1 哈密顿回路的双向链表表示法

使用双向链表来表示回路是一种自然的想法，如果希望是一段路径反向，可以直接将这段路径的第1个前驱节点连接到这段路径的末尾，并将这段路径第1个的后继节点连接到这段路径的开头。

但是这样的操作并不能修改存在于这段路径中的节点的方向，因此我们无法分辨双向链表节点的两个链域分别应该指向这个节点的前驱节点还是后继节点。

我们的解决方案是：在遍历链表节点时，除了保存当前节点的指针$cur$，还额外保存一个当前节点的前驱节点的指针$pre$。在遍历下一个节点时，先使用$pre$与$cur$的两个链域做比较，选择其中不等于$pre$的链域作为$cur$的后继节点，将$cur$赋值给$pre$，并将后继节点赋值给$cur$。

选择记录当前节点的前驱节点$pre$而不是记录当前节点的后继节点的原因是：算法在编码实现时需要频繁交换连接两个节点的后继节点，只保留前驱节点可以减少额外的赋值操作。

**操作实现**：

1 **访问前驱/后继节点**

如上所述。

2 **翻转区间**

1. 输入需要反转的区间的第1个前驱节点`before_first`和这段区间的最后一个节点`before_last`；
2. 通过`before_first`和`before_last`得到这段区间的第1个节点`first`和第1个后继节点`last`；
3. 将`before_first`的后继节点设置为`before_last`；
4. 将`before_last`的前驱节点设置为`before_first`；
5. 将`first`的后继节点设置为`last`；
6. 将`last`的前驱节点设置为`first`；
7. 令`before_last:=first`，即保持`before_last`在3重循环时所指向的位置不发生改变。

**时间复杂度**：

均为$O(1)$
